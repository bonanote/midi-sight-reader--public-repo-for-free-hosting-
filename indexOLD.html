<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Sight Reader - Treble Chromatic</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vexflow/3.0.9/vexflow-min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
        }
        #staff {
            margin: 20px auto;
            border: 1px solid #ccc;
            background: white;
            transition: background-color 0.3s ease;
        }
        #status {
            margin: 10px;
            font-size: 18px;
            color: #333;
        }
        #ledger {
            margin: 10px;
            font-size: 14px;
            color: #666;
            text-align: left;
            max-width: 500px;
            margin: 10px auto;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        #ledger:empty {
            display: none;
        }
        .wrong-entry {
            display: inline-block;
            margin-right: 15px;
            padding: 2px 5px;
            background: #ffe6e6;
            border-radius: 3px;
        }
        .range-controls {
            margin: 10px;
            font-size: 16px;
        }
        .range-controls label {
            margin: 0 10px;
        }
        .range-controls input {
            width: 60px;
            padding: 4px;
        }
        .correct-flash {
            background-color: rgba(0, 255, 0, 0.3) !important;
        }
        .wrong-flash {
            background-color: rgba(255, 0, 0, 0.3) !important;
        }
        #stats {
            margin: 10px;
            font-size: 16px;
            color: #333;
            text-align: center;
            background: #e8f5e8;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #4caf50;
        }
    </style>
</head>
<body>
    <h1>MIDI Sight Reader</h1>
    <p>Connect your MIDI keyboard and play the note shown on the staff!</p>
    <div id="status">Loading VexFlow...</div>
    <div class="range-controls">
        <label for="minPitch">Min MIDI: <input type="number" id="minPitch" value="53" min="0" max="127" step="1"></label>
        <label for="maxPitch">Max MIDI: <input type="number" id="maxPitch" value="88" min="0" max="127" step="1"></label>
    </div>
    <div id="stats"></div>
    <div id="ledger"></div>
    <button id="connectBtn" style="display:none;">Connect MIDI</button>
    <div id="staff"></div>

    <script>
        let VF = null; // Global VF - will be set after load check
        let midiAccess = null;
        let inputPort = null;
        let targetPitch = null;
        let lastPitch = null; // Track last pitch to avoid repeats
        let wrongCounts = new Map(); // Track {pitch: count} for wrongs
        let totalCorrect = 0; // Total correct plays
        let totalWrongs = 0; // Total wrong plays
        let minPitch = 53;
        let maxPitch = 88;

        // Debug: Check if VexFlow loaded and set VF globally
        window.addEventListener('load', () => {
            if (typeof Vex === 'undefined') {
                document.getElementById('status').textContent = 'Error: VexFlow failed to load. Check internet or script src.';
                console.error('VexFlow not found');
                return;
            }
            VF = Vex.Flow;
            console.log('VexFlow loaded successfully, VF set.'); // Debug

            // Set up range input listeners
            document.getElementById('minPitch').addEventListener('change', (e) => {
                minPitch = parseInt(e.target.value) || 53;
                if (minPitch > maxPitch) maxPitch = minPitch;
                e.target.value = minPitch;
            });
            document.getElementById('maxPitch').addEventListener('change', (e) => {
                maxPitch = parseInt(e.target.value) || 88;
                if (maxPitch < minPitch) minPitch = maxPitch;
                e.target.value = maxPitch;
            });

            document.getElementById('status').textContent = 'Ready. Click "Connect MIDI" to begin. (Open Console for debug logs)';
            document.getElementById('connectBtn').style.display = 'block';
        });

        // Function to get note info from MIDI pitch with random sharp/flat
        function getNoteInfo(pitch) {
            const octave = Math.floor(pitch / 12) - 1;
            const semitone = pitch % 12;

            let base, accidental = null, displayName;

            // Natural notes
            const naturalSemis = [0, 2, 4, 5, 7, 9, 11];
            const naturalBases = ['c', 'd', 'e', 'f', 'g', 'a', 'b'];

            if (naturalSemis.includes(semitone)) {
                const idx = naturalSemis.indexOf(semitone);
                base = naturalBases[idx];
                displayName = base + '/' + octave;
            } else {
                // Chromatic (black keys) - random sharp or flat
                const blackKeys = {
                    1: {sharp: {base: 'c', acc: '#', display: 'c#'}, flat: {base: 'd', acc: 'b', display: 'db'}},
                    3: {sharp: {base: 'd', acc: '#', display: 'd#'}, flat: {base: 'e', acc: 'b', display: 'eb'}},
                    6: {sharp: {base: 'f', acc: '#', display: 'f#'}, flat: {base: 'g', acc: 'b', display: 'gb'}},
                    8: {sharp: {base: 'g', acc: '#', display: 'g#'}, flat: {base: 'a', acc: 'b', display: 'ab'}},
                    10: {sharp: {base: 'a', acc: '#', display: 'a#'}, flat: {base: 'b', acc: 'b', display: 'bb'}}
                };
                const choice = Math.random() < 0.5 ? 'sharp' : 'flat';
                const selected = blackKeys[semitone][choice];
                base = selected.base;
                accidental = selected.acc;
                displayName = selected.display + '/' + octave;
            }

            const baseKey = base + '/' + octave;
            return {baseKey, accidental, displayName};
        }

        // Function to generate random pitch in user-defined range, avoiding lastPitch
        function generateRandomPitch() {
            if (minPitch > maxPitch) {
                console.warn('Min > Max, using defaults');
                return Math.floor(Math.random() * (88 - 53 + 1)) + 53;
            }
            let newPitch;
            do {
                newPitch = Math.floor(Math.random() * (maxPitch - minPitch + 1)) + minPitch;
            } while (newPitch === lastPitch); // Avoid repeat
            return newPitch;
        }

        // Function to draw the staff and note
        function drawNote(noteInfo) {
            if (!VF) {
                console.error('VF not ready yet - VexFlow not loaded.');
                document.getElementById('status').textContent = 'VexFlow not ready. Reload and try again.';
                return;
            }
            const div = document.getElementById('staff');
            div.innerHTML = ''; // Clear previous
            // Clear any flash classes
            div.classList.remove('correct-flash', 'wrong-flash');

            const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
            renderer.resize(500, 200);
            const context = renderer.getContext();
            context.setBackgroundFillStyle('#eed');

            const stave = new VF.Stave(10, 40, 400);
            stave.addClef('treble').addTimeSignature('4/4');
            stave.setContext(context).draw();

            const note = new VF.StaveNote({
                clef: 'treble',
                keys: [noteInfo.baseKey],
                duration: 'q'
            });

            // Explicitly add accidental if present to ensure symbol displays
            if (noteInfo.accidental) {
                note.addAccidental(0, new VF.Accidental(noteInfo.accidental));
            }

            const voice = new VF.Voice({ num_beats: 1, beat_value: 4 });
            voice.addTickable(note);
            new VF.Formatter().joinVoices([voice]).format([voice], 400);
            voice.draw(context, stave);
        }

        // Function to flash the staff
        function flashStaff(correct) {
            const staffDiv = document.getElementById('staff');
            const className = correct ? 'correct-flash' : 'wrong-flash';
            staffDiv.classList.add(className);
            setTimeout(() => {
                staffDiv.classList.remove(className);
            }, 300);
        }

        // Function to update the wrong notes ledger display
        function updateLedger() {
            const ledgerDiv = document.getElementById('ledger');
            if (wrongCounts.size === 0) {
                ledgerDiv.innerHTML = '';
                return;
            }
            // Sort by count descending, then pitch
            const sortedWrongs = Array.from(wrongCounts.entries())
                .map(([pitch, count]) => {
                    const noteInfo = getNoteInfo(pitch);
                    const noteName = noteInfo.displayName.replace(/\d+$/, ''); // Remove octave for display
                    return {noteName, pitch, count};
                })
                .sort((a, b) => b.count - a.count || a.pitch - b.pitch);
            ledgerDiv.innerHTML = '<strong>Wrong Notes:</strong> ' + 
                sortedWrongs.map(entry => 
                    `<span class="wrong-entry">${entry.noteName} ${entry.pitch} wrong ${entry.count}</span>`
                ).join(' | ');
        }

        // Function to update stats display
        function updateStats() {
            const totalPlayed = totalCorrect + totalWrongs;
            const percentage = totalPlayed > 0 ? Math.round((totalWrongs / totalPlayed) * 100) : 0;
            document.getElementById('stats').textContent = `Notes Played: ${totalPlayed} | Wrongs: ${totalWrongs} (${percentage}%)`;
        }

        // Generate and display next note
        function generateNext() {
            if (!VF) {
                console.error('Cannot generate note: VF not defined.');
                return;
            }
            targetPitch = generateRandomPitch();
            const noteInfo = getNoteInfo(targetPitch);
            drawNote(noteInfo);
            document.getElementById('status').textContent = `Target: Pitch ${targetPitch} (${noteInfo.displayName}) - Play it!`;
            lastPitch = targetPitch; // Update last for next time
            console.log('New target pitch:', targetPitch, 'as', noteInfo.displayName, 'with accidental:', noteInfo.accidental); // Debug
        }

        // MIDI message handler
        function onMIDIMessage(event) {
            const data = event.data;
            console.log('Incoming MIDI data:', data); // Debug: See all messages
            const status = data[0];
            if (status >= 144 && status < 160) { // Note On (channels 1-16)
                const noteNumber = data[1];
                const velocity = data[2];
                console.log('Note On detected: Pitch', noteNumber, 'Velocity', velocity); // Debug
                if (velocity > 0) {
                    if (noteNumber === targetPitch) {
                        console.log('Match! Advancing...'); // Debug
                        totalCorrect++;
                        flashStaff(true); // Green flash
                        document.getElementById('status').textContent = 'Correct! Next note...';
                        updateStats();
                        setTimeout(generateNext, 500); // Brief feedback
                    } else {
                        console.log('No match - expected', targetPitch); // Debug
                        totalWrongs++;
                        flashStaff(false); // Red flash
                        // Increment wrong count
                        const currentCount = wrongCounts.get(noteNumber) || 0;
                        wrongCounts.set(noteNumber, currentCount + 1);
                        updateLedger(); // Refresh display
                        updateStats();
                    }
                }
            }
        }

        // MIDI success callback
        function onMIDISuccess(midi) {
            if (!VF) {
                document.getElementById('status').textContent = 'VexFlow not ready. Wait or reload.';
                return;
            }
            midiAccess = midi;
            const inputs = Array.from(midi.inputs.values()); // List all
            console.log('Available MIDI inputs:', inputs.map(i => ({name: i.name, id: i.id}))); // Debug: See devices
            // Prioritize 'EWI-USB' or real devices, avoid 'Network Session'
            inputPort = inputs.find(i => i.name && i.name.includes('EWI'));
            if (!inputPort) {
                inputPort = inputs.find(i => i.name && !i.name.includes('Network') && !i.name.includes('Session') && !i.name.includes('Through') && !i.name.includes('Dummy'));
            }
            if (!inputPort) inputPort = inputs[inputs.length - 1]; // Fallback to last (often the physical device)
            if (inputPort) {
                console.log('Selected input:', inputPort.name); // Debug
                inputPort.onmidimessage = onMIDIMessage;
                document.getElementById('status').textContent = `MIDI Connected via "${inputPort.name || 'Unknown'}! Generating first note...`;
                document.getElementById('connectBtn').textContent = 'Reconnect MIDI';
                // Reset counters and ledger on new session
                wrongCounts.clear();
                totalCorrect = 0;
                totalWrongs = 0;
                lastPitch = null;
                updateLedger();
                updateStats();
                generateNext();
            } else {
                document.getElementById('status').textContent = 'No MIDI input found. Connect a device.';
            }
        }

        // MIDI failure callback
        function onMIDIFailure(error) {
            console.error('MIDI Error:', error);
            document.getElementById('status').textContent = 'MIDI access denied or unavailable. Try in Chrome/Edge.';
        }

        // Connect button handler
        document.getElementById('connectBtn').addEventListener('click', () => {
            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
            } else {
                alert('Web MIDI not supported in this browser.');
            }
        });
    </script>
</body>
</html>
